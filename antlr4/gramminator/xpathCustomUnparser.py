# Generated by Grammarinator 18.10

import json
import random

from os.path import dirname, join

from grammarinator.runtime import *
from xpathUnparser import xpathUnparser


with open(join(dirname(__file__), 'xpath.json')) as f:
    tags = json.load(f)



class xpathCustomUnparser(xpathUnparser):

    attr_stack = []
    tag_stack = []
    tags = set()

    def __init__(self, unlexer):
        super(xpathCustomUnparser, self).__init__(unlexer)
        self.tag_names = list(tags.keys())

    # Override the original random_decision implementation in a way to increase the number of generated nodes.
    def random_decision(self):
        # Playing with size.
        if self.node_cnt < 100 // 4:
            return random.randint(0, 1000) > 100
        return random.randint(0, 1000) < 400

    # def nCName(self):
    #     current = self.create_node(UnparserRule(name='nCName'))
    #     current += "Book"
    #     return current


    def functionName(self):
        current = self.create_node(UnparserRule(name='functionName'))
        name = "string"
        current += UnlexerRule(src=name)
        return current
    functionName.min_depth = 1

    @depthcontrol
    def nCName(self):
        current = self.create_node(UnparserRule(name='nCName'))
        choice = self.choice([0 if [2, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_242', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_242', choice)] = self.unlexer.weights.get(('alt_242', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            name = random.choice(self.tag_names)
            current += UnlexerRule(src=name)
        elif choice == 1:
            current += self.unlexer.AxisName()
        elif choice == 2:
            current += self.unlexer.NodeType()
        return current
    nCName.min_depth = 1